<html lang="en">
  <head>
    <meta charset="utf-8">
    <title> Altizure Markercluster</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  </head>
  <body>
    <div id="page-content"></div>
    <script type="text/javascript" src="https://beta.altizure.com/sdk"></script>
    <script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.3.1.min.js"></script>
    <script src="../third_party/osmtogeojson.js"></script>
    <script>
      let options = {
        altizureApi:{
          key: '7MkQf8UggsPaadvrlKALspJWZejZAJOLHn3cnIy'
        },
        renderItems: {
          earth: true,
          earthUseTexture: false,
          featureInView: false,
          orbitRing: false
        }
      }

      let sandbox = new altizure.Sandbox('page-content', options)
      let projectMarkerID = '58428f1d97b73e0b090675cd'
      // let projectMarkerID = '5723553732f7a5ee26ff526b'
      // let projectMarkerID = '5a58de8c93ac3d233f7980c5'
      let altmarker
      var tagMarkers = []
      var cluster = new altizure.MarkerCluster({
        sandbox: sandbox,
        // config: {
        //   minDistance: 30, // pixel distance,
        //   minNumber: 4, // minimum number of elements to form a cluster,
        //   method: 'dbscan'
        // }
      })
      sandbox.add('AltizureProjectMarker', {pid: '5723553732f7a5ee26ff526b'})
      sandbox.add('AltizureProjectMarker', {pid: projectMarkerID})
      .then((m) => {
        return m.initialized
      })
      .then((m) => {
        sandbox.camera.flyTo({lng: m.position.lng, lat: m.position.lat, alt: 4000}, 1)
        // console.log(`sandbox.camera.pose = {lng: ${m.position.lng}, lat: ${m.position.lat}, alt: 4000}`)
        altmarker = m
        // altmarker.visible = false
        queryForAltmarker(altmarker)
      })

      // document.addEventListener('click', (event) => {
      //   console.log(JSON.stringify(sandbox.window.toLngLatAlt(event)))
      // })
      
      function buildQuery (marker) {
        // http://overpass-api.de/query_form.html
        let lowerLat = marker._apiInfo.geoInfo.minLat
        let lowerLng = marker._apiInfo.geoInfo.minLong
        let higherLat = marker._apiInfo.geoInfo.maxLat
        let higherLng = marker._apiInfo.geoInfo.maxLong
        // let lowerLat = 22.32
        // let lowerLng = 114.25
        // let higherLat = 22.35
        // let higherLng = 114.28
        let query = ''
        query += '('
        query += 'node["building"]' + bboxStr(lowerLat, lowerLng, higherLat, higherLng) + ';'
        query += 'way["building"]' + bboxStr(lowerLat, lowerLng, higherLat, higherLng) + ';'
        query += ');'
        query += '(._;>;);'
        query += 'out;'
        function bboxStr (slat, slng, llat, llng) {
          return '('+slat+','+slng+','+llat+','+llng+')'
        }
        let bbox = {
          min: {lng: lowerLng, lat: lowerLat}, max: {lng: higherLng, lat: higherLat}
        }
        return [query, bbox]
      }
      function query_overpass (query, callback) {
        $.ajax({
          url:
            'http://overpass-api.de/api/interpreter?data=[out:json][timeout:60];' + query,
          dataType: 'json',
          type: 'GET',
          async: true,
          crossDomain: true
        }).done(function ( data, textStatus, jqXHR ) {
          // console.log('second success', data, textStatus, jqXHR)
          var error = false
          callback(error, data, textStatus, jqXHR)
        }).fail(function (jqXHR, textStatus, errorThrown) {
          console.log('error', jqXHR, textStatus, errorThrown)
          var error = true
          callback(error, jqXHR, textStatus, errorThrown)
        }).always(function () {
          console.log('complete')

          console.log('start clustering')
          setTimeout(start(100), 2000)
        })
      }
      function queryForAltmarker (marker) {
        let [query, bbox] = buildQuery(marker)
        console.log('query: ', query)

        let callback = (errorOccured, data, textStatus, other) => {
          if (!errorOccured) {
            console.log('succuss')
            let geojson = osmtogeojson(data)
            console.log(data)
            console.log(geojson)
            visualizeGeoJSONData(geojson)
          } else {
            console.log('failure')
          }
        }
        query_overpass(query, callback)
      }

      function visualizeGeoJSONData (geojson) {
        let features = geojson.features
        for (let i = 0; i < features.length; ++i) {
          let feature = features[i]
          if (feature.properties.type === 'node') {
            // visualizeAsTagMarker(feature.geometry.coordinates)
          } else if (feature.properties.type === 'way') {
            let pt = [0, 0]
            let ptarray = feature.geometry.coordinates[0]
            ptarray.map((v) => {
              pt[0] += v[0]
              pt[1] += v[1]
            })
            pt[0] /= ptarray.length
            pt[1] /= ptarray.length
            visualizeAsTagMarker(pt)
          }
        }
      }

      let positions = []
      function visualizeAsTagMarker (point) {
        let pos = new altizure.LngLatAlt(point[0],point[1],0.1)
        positions.push(pos)
        let tag = new altizure.TagMarker({
          sandbox: sandbox,
          position: pos,
          imgUrl: '../public/assets/img/tag/normal/tagDemo.png',
          scale: 2
        })
        tag.sprite.material.color.set(0xff0000)
        tagMarkers.push(tag)
        cluster.add(tag)
      }

      const debounce = (func, delay) => {
        let inDebounce
        return function() {
          const context = this
          const args = arguments
          clearTimeout(inDebounce)
          inDebounce = setTimeout(() => func.apply(context, args), delay)
        }
      }

      function start(debounce_delay) {
        sandbox.positionsAltitude(positions).map((alt, i) => {
          tagMarkers[i].position = Object.assign({}, tagMarkers[i].position, {alt: alt})
          tagMarkers[i].depthTest = true
        })
        sandbox.on('cameraChange', debounce(function () {
          cluster.clustering().then((clusters) => {
            // console.log('clusters', cluster.clustersTag.length)
            cluster.enable()
          })
        }, debounce_delay))
        cluster.clustering().then((clusters) => {
          // console.log('clusters', cluster.clustersTag.length)
          cluster.enable()
        })
      }
    </script>
  </body>
</html>